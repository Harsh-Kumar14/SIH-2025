# Real-time Chat System

A complete real-time one-on-one chat system built with Socket.IO, Express, MongoDB, and TypeScript.

## Features

- ✅ Real-time messaging with Socket.IO
- ✅ Message persistence with MongoDB
- ✅ Message status tracking (sent, delivered, read)
- ✅ Typing indicators
- ✅ Online/offline status
- ✅ Chat history retrieval
- ✅ Unread message count
- ✅ RESTful API endpoints
- ✅ TypeScript with full type safety
- ✅ Zod validation

## Project Structure

```
src/
├── chatting/
│   ├── chat.model.ts      # Data models and types
│   ├── chat.database.ts   # Database operations
│   ├── chat.service.ts    # Socket.IO service
│   └── chat.routes.ts     # HTTP API routes
├── index.ts               # Main server file
└── ...
```

## Setup

1. Install dependencies:
```bash
npm install
```

2. Start the server:
```bash
npm run start
```

3. Visit `http://localhost:8080/chat-test.html` to test the chat system

## Socket.IO Events

### Client to Server Events

- `join_room`: Join a chat room
  ```typescript
  socket.emit('join_room', { userId: 'user1', otherUserId: 'user2' });
  ```

- `send_message`: Send a message
  ```typescript
  socket.emit('send_message', {
    senderId: 'user1',
    receiverId: 'user2',
    content: 'Hello!',
    messageType: 'text'
  });
  ```

- `typing`: Send typing indicator
  ```typescript
  socket.emit('typing', {
    userId: 'user1',
    isTyping: true,
    roomId: 'chat_user1_user2'
  });
  ```

- `mark_as_read`: Mark message as read
  ```typescript
  socket.emit('mark_as_read', {
    messageId: 'messageId',
    userId: 'user1'
  });
  ```

### Server to Client Events

- `message_received`: Receive a new message
- `user_typing`: User typing indicator
- `user_online`: User came online
- `user_offline`: User went offline
- `message_status_updated`: Message status changed

## HTTP API Endpoints

### GET `/api/chat/history/:userId1/:userId2`
Get chat history between two users
- Query params: `limit` (default: 50), `offset` (default: 0)

### GET `/api/chat/recent/:userId`
Get recent chats for a user
- Query params: `limit` (default: 20)

### GET `/api/chat/unread/:userId/:otherUserId`
Get unread message count

### PUT `/api/chat/mark-read`
Mark messages as read
- Body: `{ senderId, receiverId }`

### POST `/api/chat/send`
Send a message via HTTP
- Body: `{ senderId, receiverId, content, messageType? }`

## Message Status Flow

1. **SENT** - Message is sent and saved to database
2. **DELIVERED** - Message is delivered to recipient (if online)
3. **READ** - Message is read by recipient

## Room ID Generation

Room IDs are generated by sorting user IDs alphabetically:
```typescript
// For users "user1" and "user2"
roomId = "chat_user1_user2"
```

This ensures consistent room IDs regardless of who initiates the chat.

## Database Schema

### Message Document
```typescript
{
  senderId: string;
  receiverId: string;
  content: string;
  messageType: 'text' | 'image' | 'file';
  timestamp: Date;
  status: 'sent' | 'delivered' | 'read';
  chatRoomId: string;
}
```

## Usage Example

### Frontend Integration

```javascript
// Connect to socket
const socket = io('http://localhost:8080');

// Join a chat room
socket.emit('join_room', { userId: 'user1', otherUserId: 'user2' });

// Send a message
socket.emit('send_message', {
  senderId: 'user1',
  receiverId: 'user2',
  content: 'Hello there!'
});

// Listen for messages
socket.on('message_received', (message) => {
  console.log('New message:', message);
});

// Listen for typing indicators
socket.on('user_typing', (data) => {
  console.log(`${data.userId} is typing: ${data.isTyping}`);
});
```

## Environment Variables

- `PORT` - Server port (default: 8080)
- MongoDB connection should be configured in your database connection file

## Testing

Visit `http://localhost:8080/chat-test.html` for a simple test interface where you can:
- Connect as different users
- Send real-time messages
- See typing indicators
- View chat history
- Test online/offline status

## Production Considerations

1. **CORS Configuration**: Update CORS settings for production
2. **Authentication**: Add user authentication and authorization
3. **Rate Limiting**: Implement rate limiting for message sending
4. **Error Handling**: Add comprehensive error handling
5. **Logging**: Add proper logging for monitoring
6. **Scaling**: Consider Redis adapter for Socket.IO clustering
7. **File Upload**: Implement file/image upload functionality
8. **Message Encryption**: Add end-to-end encryption for sensitive data
